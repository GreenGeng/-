package summary.redis;

public class Summary1 {
    /**
     * rdb和aof怎么配合使用
     * 使用rdb恢复内存状态会丢失大量数据
     * 使用AOF重放性能比较低
     *
     * 开启混合持久化 在AOF重写时 把重写前的内存做RDB快照，并且将快照和增量的AOF修改内存数据的命令存在一起，都写入AOF中，
     * 等重写完新的AOF文件覆盖原来文件
     *（先RDB快照 然后重写 然后把快照+新增的命令放一起写到AOF 替换旧的 就是在重写之前加个rdb快照）
     *
     * redis数据备份策略
     * 写crontab定时调度脚本，每小时copy一份到rdb或者aof的备份到一个目录中 ，仅保留最近两天备份
     * 每天保留一份当日的数据备份到一个目录中，可以保留最近一个月的备份
     * 每次copy备份的时候 把太旧的备份删除
     * 每天晚上将当前的备份复制到一份到其他机器上
     *
     *
     *
     * redis常用指令
     * keys 查询所有key
     * string：set、get、append、incr key(key的value+1)、decr key、mset（批量插入）、mget、msetnx(批量插入key不存在的数据)
     * list: lpush (一个或多个）、lrange（获取指定区间的值）、lpop、rpush、rpop、lrem、lindex
     * set: setadd(一个或多个)、smembers(获取指定key的所有元素)、srem、spop、
     * hash: hset(一个或多个)、hget、hgetall、hexists、hdel、hlen
     * zset: zdd、zrange、zrem、zrank（获取指定元素的排名）、zcount（获取指定区间里元素的个数）、zscore(获取指定元素的分数)
     *
     *
     * aof文件太大的话就重写
     * aof重写的过程
     * 创建一个子进程，子进程将历史插入语句写到临时的AOF文件里，主进程一边处理请求，一边把写命令加到aof文件和缓冲区里
     * 子进程完成后给父进程发送一个信号
     * 父进程把重写缓冲区里的命令加载到新AOF文件里
     *
     *
     *
     *
     *
     * 布隆过滤器
     *
     *
     * redis里的事务
     * redis事务里没有回滚，没有原子性，如果有一个命令失败，其他命令会继续
     * mysql是在commit提交之前 只要提交命令都会执行 redis是没有exec命令就不会执行 所以不存在脏读那些 也没有事务隔离级别
     * 如果事务出现问题可以放弃事务（discard）
     * 注意如果是语法错误 那事务里的其他语句都不会执行
     * 如果是逻辑错误 一条语句出现问题 其他不会影响
     *
     *
     * redis五种数据类型的数据结构
     * string：最大512m 可以存任何类型的数据 包括图片
     * SDS好处：获取字符串长度很快，二进制安全（他的API是安全的）、不会造成缓冲区溢出（因为有个字段是记录空闲大小的 如果不够会先扩容 避免溢出）
     * list 双端链表+压缩链表
     * 数据量较少的时候是一块连续的内存 为压缩列表
     * set 字典
     * 无序、唯一的集合
     * zset 压缩链表+跳表
     * 有序 、唯一的集合
     * 里面有一个score 代表权重
     * hash 压缩链表+字典
     * 字典：类似hashmap
     *
     *
     * redis分布式锁
     * 分布式环境下 一个方法在一个时间点只能被一个线程执行
     *
     * 当方法被线程锁住就创建一个记录  set lock 线程ID
     * 如果线程去redis寻找该lock记录 没有就添加记录 setnx 赋值并加上过期时间
     * 如果不是空 就已经加锁了 就等待（cas）
     *
     *
     * redis做消息队列的缺点
     * 不能广播
     * 不能重复消费
     * 可能数据丢失
     * 不能分组消费
     * 消息确认麻烦
     *
     *
     *
     *
     * 除了redis分布式锁 还可以用数据库实现分布式锁
     * 在数据库里创建一个表
     * 表里存方法名 并使用唯一键
     * 当方法被调用的时候 就把方法存到表里
     * 其他线程调用前先去表里看下方法有没有调用 有就不能调用
     * 等到方法被调用完 把该记录删除就行
     *
     *
     *
     * 分布式ID
     * uuid 太长 不适合
     */


}
