package summary.redis;

public class Summary2 {
    /**
     * redis会有线程安全问题吗
     * 不会 他是单线程
     * redis为什么是单线程
     * 因为redis主打的就是效率高，他使用单个CPU绑定一块内存数据，对这块内存数据进行读写的时候都是使用一个CPU完成的
     * 就不需要像多线程还需要等待线程上下文切换  而且内存读取数据就比磁盘快
     *
     * 他的瓶颈在于网络和内存
     *
     * redis的锁续命
     * 首先获取到锁 30s自动释放 然后对锁设置一个延时任务
     * 该任务会给锁的释放时间刷新为30s 并且在设置相同的延时任务
     * 如果程序没执行完 他就会每10s刷一下释放时间
     *
     *
     *
     * 为什么主从复制
     * 单节点的redis的QPS不适合千万的用户访问 而且单节点的Redis不能保证高可用，如果意外宕机，可能会导致缓存不可用
     * 好处：
     * 负载均衡、故障恢复、数据冗余
     * 流程
     * Slave连上master，开始数据同步，发送psync命令
     * Master收到psync命令之后开始执行bgsave生成RDB快照数据并使用缓存区记录后米娜的写命令
     * 如果master收到多个slave并发连接请求 ，他只会进行一次持久化，不是每个连接都执行一次
     * Master执行完bgsave之后 就会向所有的slave服务器发送快照文件，并在发送期间会继续记录执行的写命令
     * Slave收到RDB快找文件之后 就会把收到的数据写到磁盘里 清空所有旧的数据 然后从本地磁盘载入收到的快照到内存里 同时基于旧的数据版本对外服务
     * Master发送完rdb快照 就开始向slave发送缓存区的写命令
     * Slave完成对快照的载入 开始接受命令请求
     *
     */
}
