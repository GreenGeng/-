package summary.jvm;

public class Summary2 {


    /**
     *
     * 类加载流程
     * 加载-》检验-》准备-》解析-》初始化
     * 加载：把Java字节码文件加载到JVM中
     * 检验：检查加载的字节信息是否符合JVM规范
     * 准备：创建静态变量并赋值
     * 解析：把符号引用转为直接引用--
     * 初始化：
     * （字节码-》规范-》静态变量-》直接引用-》初始化）
     *
     *
     * 年轻代和老年代的比例（1：2） 比例可以修改 用-XX:NewRatio
     * 堆=新生代（1/3）+老年代（2/3）
     * 堆的大小通过-Xms和-Xmx来指定
     *
     *
     * 类加载器有哪些
     * 类加载器：用来加载类到JVM中
     * 自定义类加载器->应用类加载器->扩展类加载器->启动类加载器
     *
     * 对象的创建
     * （遇到new-->常量池检查--->类加载---》分配内存空间--》初始化为0--》设置对象头）
     * 当JVM遇到new指令的时候 首先去检查常量池里这个类的符号引用，并检查这个类是否已经被加载、解析，
     * 如果没有就执行对应的类加载过程--
     * 类加载检查通过就可以给对象分配内存空间（指针碰撞+空闲列表方式）
     * 内存分配完之后，将分配到的内存空间初始化为0（不包括对象头）
     * 设置对象头信息
     *
     *
     *
     * JVM常见参数
     * -Xmx 初始堆和-Xms 最大堆
     * -Xss 栈
     *  -Xmn年轻代
     *
     *
     *   为什么要常量池
     *  减少内存开销
     *
     *
     *
     *  OOM
     *  堆内存不够了
     *  原因：垃圾对象没有回收（内存泄漏）、创建了超大数组对象、过度使用了finalizer（）
     *
     *  解决：
     *  -Xmx调大JVM堆内存空间
     *  如果是超大对象 检查一下他的合理性 是不是可以缩小
     *  如果是内存泄漏 ，找到为什么没有释放的原因（找到持有的对象，例如流没有关闭等）
     *
     *
     *
     * 栈溢出
     * 栈里存放的是方法信息和对象的引用
     * 如果栈溢出 方法参数不要定义大型结构、减少函数调用的层次、（递归使用不当会栈溢出）
     * 不要定义占用内存较多的变量
     * -Xs
     *
     *  永久代是什么
     *  用于存放静态文件如Java类、方法等
     *  方法区存放的是常量、静态变量
     *
     *
     *
     *  访问对象的方式
     *  句柄、指针
     *
     * minorGC（youngGC ）：Eden区满了
     * FullGC：执行System.gc()、老年代空间不足、
     *
     * fullGC频繁会影响性能
     * 因为fullGC 会导致Stop the world，STW就是用户线程运行到安全区域之后就会挂起
     * (minor gc也会Stw 只是时间长短不一样)
     *
     * Java里的引用类型
     * 强、软、弱、虚
     * 强引用：（永远不会被回收）String str="hello" 回收：赋值为null
     * 软引用：内存溢出前会被回收 SoftReference来引用对象 --
     * 弱引用：只要回收器扫描到就会回收  WeakReference来引用的
     * 虚引用：形同虚设 根没有引用一样
     *
     * 主动通知虚拟机垃圾回收：
     * System.gc
     *
     * CMS收集器
     * 采用标记-清除算法
     * 初始标记：标记GCroot直接关联的对象
     * 并发标记：标记所有可达的对象
     * 重新标记：标记上层发生变化的对象
     * 并发清除：GC线程回收不可达对象
     *
     * 缺点：内存碎片化问题
     *
     *
     * G1收集器
     * 初始标记：标记GC root直接关联的对象
     * 并发标记：可达性分析
     * 最终标记
     * 筛选回收
     *
     * G1整体是标记整理
     * G1不会产生内存碎片
     *
     *
     *
     *
     */
}
