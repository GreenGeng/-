package summary.jvm;

public class Summary3 {
    /**
     * 基础不行：计算机网络 、 操作系统、 编译原理、数据结构 基本上都很差
     * 但是现在来不及具体补  哪里涉及到就补哪里
     *
     * 为什么Java里代码不是顺序执行的
     * 父类静态代码块 子类静态代码块 父类构造 子类构造
     * 有优先级 类初始时候 静态代码块会优先执行
     *
     *  同一个函数里 代码也不是顺序执行的
     *  因为假如第一个指令要先去通过总线寻址 获取数据
     *  如果需要很长的时间 CPU没必要非要等他从内存中获取到值
     *  CPU可以先去执行第二个指令
     *
     * G1 收集器
     * 是老年代和新生代共用的
     * STW时间是根据垃圾标记所需的时间确定的
     * STW是避免不了的 只能减少
     * 过程、
     * 先记录GCRoot直接引用的对象、
     * 进行可达性分析
     * 修复一些引用会状态
     * 筛选回收
     * G1使用多个CPU来缩短STW的时间
     *
     * 什么场景适合G1
     * 堆内存比较大
     * 垃圾回收时间长
     * 停顿时间在500ms以内
     * 50%以上的堆被存活对象占用
     *
     *
     * STW在安全区域才会执行
     * 安全区域：
     * 方法返回前
     * 调用某个方法后
     * 抛异常的位置
     * 循环的末尾
     *
     *
     * 为什么是8：1：1
     * 因为内存达到90%的时候需要GC
     * eden+s0就是90%
     * 剩下10%用来存放获得对象
     *
     *
     * 双亲委派机制的过程
     * 避免核心类库被篡改
     * 使用了责任链的模式
     * 向上委托
     * 应用 扩展 引导
     *
     *
     * 值传递和引用传递
     * 值传递 方法里传递的是值
     * 引用传递 方法里传递的是地址
     *
     *
     * JVM由哪些部分组成
     * 类加载子系统、JMM、执行引擎
     * 执行引擎就是执行JVM字节码指令
     *
     *
     * 守护线程
     * 是给用户线程提供服务的线程 生命周期是跟用户线程有关的
     * 有用户线程 守护线程才有意义
     *
     *
     *
     *
     *
     */
}
