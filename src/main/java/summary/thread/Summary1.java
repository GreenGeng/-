package summary.thread;

public class Summary1 {
    /**
     *
     * 线程池的工作流程
     * 就是corePoolSize、maxPoolSize、和阻塞队列的关系
     *
     * Sleep wait
     * wait需要在同步上下文中调用，用notify唤醒，是实例方法，会释放锁
     * sleep不需要，超时就能唤醒，静态方法，不释放锁
     *
     * Thread的sleep会进入什么状态
     * 阻塞态，因为就绪态的话，CPU是随时可以调度的，在sleep这段时间，cpu调度不到该线程，所以是阻塞态，
     * 等结束之后就是就绪态
     *
     *
     * 如何查看线程死锁
     * jstack命令
     *
     * 线程之间如何通信
     *
     *
     *
     *
     * 偏向锁
     * 在锁对象的对象头里会记录当前获取到锁的线程ID 下次该线程在来获取锁就可以直接获取
     * 轻量级锁
     * 轻量级锁是由自旋锁来实现的 不回线程阻塞
     * 自旋锁
     * 线程一直循环去获取锁 防止CPU从用户态转内核态
     * 自旋锁次数过多都没有获得锁就会成为重量级锁 导致线程阻塞
     *
     *
     *
     *
     */
}
