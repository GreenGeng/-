package summary.mq;

public class Test2 {
    /**
     * 消息队列幂等性
     *
     * 解决：
     * 方法1 建立一个已经消费消息的表，每次消费之前检查一下表里有没有消费记录，如果有记录就是已经消费了就直接返回
     * 方法2 基于redis（也是记录消息是否消费过）
     * 使用set 消费消息前去redis里查看一下有没有该消息的唯一标识 如果有就说明已经消费过消息里 就直接返回
     * 或者自定义一个唯一性key 先去redis里查看一下有没有该key 有就说明消费了 已经记录 就直接返回
     *
     * 死信队列
     * 用来存放没有成功消费的信息，通常用来做消息重试
     * 有效期也是三天
     *
     *
     * 消费模式：集群、广播
     * 消费者消费模式：推、拉
     *
     * 消息堆积
     *
     *
     * topic和group
     * group表示一类producer和consumer 这类通常生产或者消费同一类消息
     * 同一个Group下的所有消费者必须保证topic一致
     *
     *
     *
     *
     */
}
