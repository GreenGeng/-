package summary.net;

public class Summary2 {
    /**
     * 单点登陆
     * 方法1 用户登入一个模块后 把session存储到服务器 然后把该session往别的模块到服务器都复制一份 登陆时候就不用重新登陆
     * 方法2
     * 使用cookie+redis
     * 用户登陆一个模块的时候，把用户ID作为key存储到redis里 value为用户信息，key要保证唯一性，然后把key加到cookie里
     * 用户用该cookie去访问别的模块，服务端先根据cookie里到key去redis查找看有没有该用户信息
     * 方法3
     * 使用token（规则生成的字符串）
     * 用户访问一个模块的时候，服务器端会给他返回一个字符串（可以包含用户信息的字符串），用户访问别的模块请求就会带着这个字符串（字符串可以是在cookie里，
     * 也可以在地址栏里）服务端解析字符串就能判断是不是用户信息
     *
     *
     *
     * 拥塞控制
     * 慢开始、拥塞避免、快重传、快恢复
     *
     *
     * 根服务器（根域名服务器 主要负责顶级域名的解析）
     * 13台根服务器 一个主根 12个辅根 根服务器里面的记录很少 主要存储的是顶级域名
     * 我们访问的是递归域名服务器 递归域名服务器在运营商中 递归域名服务器会存储根服务器的镜像数据 起到了根服务器的作用
     *
     *
     * 顶级域；最后一级的那个域名
     * gtld 通用顶级域
     * ggtld 国家顶级域
     * 根域名服务器
     * 根镜像节点是根域名服务器的数据同步 但是没有数据修改的权限
     *
     * OSI七层：应 表 会 传 网 数 物
     * TCP/IP四层：应 传 网 数
     * 实际：应 传 网 数 物
     *  引用层传输的数据：报文
     *  传输层：段
     *  网络层：包
     *  数据链路层：帧
     *  物理层：比特
     *  报文+原端口+目标端口==段
     *  段+源Ip+目标IP = 包
     *  包+源MAC+目标Mac=帧
     *
     *  网络号+主机号--》完整IPV4
     *  为了解决简单分类导致的IP分配不合理 就造成了子网掩码
     *
     *
     *  ssl证书 服务器申请证书的原因就是让别人知道自己是真实的 不是伪装的
     *  客户端检验SSL证书就是确保避免出现服务器是伪造的情况
     *  等会试着抓一个https的包
     *
     *
     *  http之间的区别
     *  1.1会队头阻塞
     *  2 多路复用
     *
     *
     *
     * NIO编程
     *
     *
     *
     *
     *
     *
     */


}
